---
sidebar_position: 7
title: Model Setup
---

## Introduction

Based on scaffolding of microservice project,
there will be right place to put project configurations for each module and also common settings.
The model configuration discussed in this document is a part of the project configuration.

The configurations for model/data setup cover not only the entity model with relationships
but also all the different databases the project will use, how the data syncs between them
and the Single Source of Truth settings for all entities.

---

## Setup of the DBs

In the configuration/databases/{db.toml} files there will be settings for respective dbs that are included in this project.

```
//elasticsearch.toml
name = elasticsearch
maxConnections = 200
apiVersion = '7.4'
requestTimeout = 90000
node = 'http://localhost:9200'
sniffOnStart = true
```

---

## **Entities and model**

We use the word entities (similar to rows in MySQL, or nodes in a Graph) for
refering to individual data points of a particular type.
Each entity has an id, type, fields like text, date etc. and relationships (akin to foreign keys).
The configurations of a field are all declared in one file.

Each entity is stored in a separate table/index/colelction depending on the database used.
The name of that will be pluralized and autogenerated as {entity.\_type + ‘s’}

For example, for type video, the collection/index/table name will be videos

**The simple fields of an entity and their settings are defined in**

> configFolder/schema/entities/{entityType}.toml

As per the definitions, the schema in the datastores (ES or PG) is generated from here. The migrations also make use of these definitions, to run.

Here is a sample config for a sample entity type in TOML format

```
sstDB = postgres //The main DB for this entity as its SST.
All writes will happen here first, and later the other DBs
will get eventually (automatically) synced through CDC mechanism.

[name]
type = 'String'
enum = ['value1', 'value2']
multiLingual = true
[name.postgres]
sortable = true //Will create index for this to sort on, in PG
[name.elasticsearch] //Create appropriate indices in ES for
the queries we wish to do on this field
autoSuggestion = true
exactMatch = true
sortable = true
```

Corresponding document of an Event, when returned from the
API will look like shown below. It does not matter
which underlying database the information is being fetched from.

```
{
  "_type": "person",
  "_id": "294464",
  "_version": 4,
  "data": {
    "tibetan": {
      "name": "ཆེན་པོ་མཆོག་ནས་ནང་ཆོས་ངོ་སྤྲོད་སྩལ་།",
    },
    "english": {
      "name": "His Holiness the Fourteenth Dalai Lama.",
    }
  }
}
```

The data model you set is used to generate the appropriate schema in respective databases.

---

## **Relationships**

> You must define the relationships of your data model in

> configFolder/schema/relationships.txt

_It is compulsory to maintain relationship name both ways, from Entity A to B, and B to A._ This is so that one can express Graph traversal from both sides.

The format for specifying relationships in relationship file is

```
relationNameFromAToB <> relationNameFromBToA
entityTypeA <> entityTypeB //One to one

relationNameFromAToB <> relationNameFromBToA
[entityTypeA] <> entityTypeB //Many to one

relationNameFromAToBs <> relationNameFromBToA
entityTypeA <> [entityTypeB] //One to many

relationNameFromAsToBs <> relationNameFromBsToAs
[entityTypeA] <> [entityTypeB] //many to many
```

_As you can see, when an entity type is surrounded by square brackets [], it means cardinality of many_

Some examples

```
speakers <> events
[event] <> [speaker]
sessions <> event
event <> [session]

```

Example link call

```
es.deep.link({
	e1: {
		_type: ‘event’,
		_id: ‘674’
	},
	e2: {
		_type: session,
		_id: 4
	},
	e1ToE2Relation: ‘sessions’
})
.then(console.log)
```

---

## denormalisation

**We use denormalisation to make it fast**

> Settings configFolder/schema/denormalisation.txt

Imagine you have a database composed of events, speakers and persons.

And, you wish to do the following two queries.

- Search events by speakers.person.name
- Show countwise breakup of search results on events, based on speakers.person.name (like on ecommerce sites)

> If your tables have only the foreign keys, you will have to do multiple hits to implement such cross table queries. And they will be slow. Depending on your data size, this may take a long long time before the final query result is returned. Also, your database will most probably get under heavy load.

_With Godspeed you can denormalize based on simple rule setting and achieve the same result with a single hit to the database. _

By denormalizing (always ensuring latest copy of) the speaker.person.name information within the event object, _during index, update, link or unlink calls_.

For example, here is how ‘event’ may look like in denormalization settings (in the file joins/index.txt)

```
[event]
sessions{title, description}
speakers.person{name}
```

Based on your configuration the CRUD module works to automatically maintain the denormalised storage of speaker and session data in the event entities.
** You only need to link or unlink two entities by a relationship. Everything else is taken care by Godspeed. **

#### Maintenance of the denormalised state

Here are some scenarios in which the automatic denormalization will trigger in our example database.

- Whenever you update the name of a person, the events where he or she spoke, will also get updated with person’s new name.

- When you index (store) the event for first time in the database, and it contains speakers ids, the speaker’s name will also get copied inside the event entity as it gets stored/indexed.

- When the event is linked to a speaker, the speaker’s name will get copied inside the event entity

- When the event is unlinked from a speaker, the speaker’s id, name etc will get removed from the event entity

#### The Butterfly effect

As you just saw, any update can potentially create a ripple update across entire Graph, for maintaining correct data state as per the denormalisation and also the data dependency rules like union and copy (more on the latter below).

Since this is handled automatically, it saves the developer from the overhead of maintaining a consistent, denormalised graph state across all updates. Her code doesn’t need to save the updated field value at multiple places in the database- a big overhead, lots of confusing code, more bugs... Instead, she simply declares the behavior just once, in a human readable way. After that she leaves it to Godspeed to do all the internal bookkeeping to upkeep a correct denormalised graph state all the time.

In ElasticSearch, MongoDB and other NoSQL stores, we can make use of the JSON style storage and do the joins within one document. In comparison to SQL way of rows, the document way of NoSQL allows for the denormalization easily.

> Have a look at how the denormalized speakers relationship is stored within an Godspeed event document.

```
{
  "_index": "events",
  "_type": "event",
  "_id": "294464",
  "_version": 4,
  "_source": {
    "speakers": [
      {
        "_id": "c6c35e3b21815a4209054505ac5e1680a954efdf",
        "own": true,
        "data": {
          "person": {
            "_id": "1",
            "_version": 1,
            "data": {
              "english": {
                "name": "His Holiness the 14th Dalai Lama"
              },
              "tibetan": {
				  "name" : "ང་ས་སྐུ་ཕྲེང་བཅུ་བཞི་"
			  }
            }
          }
        }
      }
    ]
  }
}
```

---

## **Data dependency implementation**

> Note: This strategy is perhaps best applied in write less and read more scenarios.

In many data models, data of an entity in your graph may depend on the data of other related entities. For ex. if a married woman has a new child, the husband also has a new child. And vice versa.
Godspeed gives you an easy way to manage complex data dependencies between related entities of your information graph. As any update is made to any Entity in your Graph, Godspeed checks if any part of the remaining Graph should be updated by this change as per your data model settings. If yes, it updates the entire affected Graph (Butterfly effect).

_This saves LOTS of lines of code, time and effort in maintaining your inter-dependent data state so that you can move faster with your development goals._

For now Godspeed supports two kinds of dependencies - Union from and Copy.

- **Union from**

> Settings are in configFolder/schema/union.toml

Union from operation can be used to compute and store distinct values, whether relationships or data values, merged from field values of multiple related entities.

This is useful for one to many or many to many relationships. Please look at the following examples to understand.

```
[conference]
speakers = '+talks.speaker' #As soon as a talk is linked to a conferece, or an already linked talk gets linked to a speaker, *the talk’s speaker is also linked to the conference as one of its speakers, if not already linked before*. Vice versa happens if the talk is unlinked to its speaker, or the talk is removed from the conference
topics = '+talks.topics' #As soon as a talk is linked to an conference, or a topic is set to an already linked talk, the talk’s topic is also added to the conference as one of its topics, if not already there. Vice versa happens if the talk is unliked to the conference, or the topic is removed from the talk.
[‘person’]
grandChildren = +‘children.children’ #Whenever a person’s child gets a new child, the new child gets added to the person’s grandchildren
[‘folder’]
fileTypes = ‘+childFolders.fileTypes + childFiles.type’ #Calculate union of all file types existing in the entire folder tree (recursively). Anytime, any file gets added to any child folder in this tree, the type of that file gets unioned with the list of fileTypes of that child folder, and all its parent folders up in the hierarchy.
```

- **Copy**

> Settings are in configFolder/schema/union.toml

Currently the copy functionality is achieved from within the union configuration.

This is effective for many to one or one to one relations. For ex.

```
[person]
inLaws = "+spouse.parents" #This will ensure copy of in laws between husband and wife
[file]
permissions = "+folder.permissions" #Whenever a folder’s permissions are updated the underlying files’ permissions are updated automatically. You can still manually override them, without affecting the folder. But whenever the folder’s permissions are updated again, the file’s permissions will get overwritten.
```

---

## **Multi Linguality**

> Settings file: configFolder/common.toml.

In that set, `supportedLanguages = [‘english’ , ‘tibetan’, ‘thirdLanguage’]`

If your data is in a single language or is language agnostic, then supportedLanguages = []

The fields which are declared multilingual, are stored like this in the \_source of the entities.

```
"english": {
	"name": "His Holiness the 14th Dalai Lama"
},
"tibetan": {
	"name": "ྋགོང་ས་སྐུ་ཕྲེང་བཅུ་བཞི་པ།"
}
```

> When creating, updating, searching or getting an entity, you have to specify the full path of every field, including its language. In search and get calls, you specify langs parameter, for the languages in which the data is to be fetched. By default data in all supported languages is fetched.
